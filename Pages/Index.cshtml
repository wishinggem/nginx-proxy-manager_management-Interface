@page
@using Newtonsoft.Json
@model IndexModel
@{
    ViewData["Title"] = "IP Management";
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IP Address Management</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

            .header h1 {
                font-size: 28px;
                margin-bottom: 10px;
            }

        .content {
            padding: 30px;
        }

        .map-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        #map {
            height: 400px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

            .map-header h2 {
                color: #333;
                font-size: 22px;
            }

        .map-stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: white;
            padding: 10px 20px;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #667eea;
        }

        .form-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

            input[type="text"]:focus {
                outline: none;
                border-color: #667eea;
            }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

            .btn-primary:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            }

        .btn-danger {
            background: #dc3545;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
        }

            .btn-danger:hover {
                background: #c82333;
            }

        .ip-list {
            margin-top: 30px;
        }

        .list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

            .list-header h2 {
                color: #333;
                font-size: 22px;
            }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        th, td {
            padding: 15px;
            text-align: left;
        }

        th {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s;
        }

            tbody tr:hover {
                background-color: #f8f9fa;
            }

        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-allow {
            background: #d4edda;
            color: #155724;
        }

        .badge-block {
            background: #f8d7da;
            color: #721c24;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .message {
            padding: 12px 20px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

            .message.success {
                background: #d4edda;
                color: #155724;
                border: 1px solid #c3e6cb;
            }

            .message.error {
                background: #f8d7da;
                color: #721c24;
                border: 1px solid #f5c6cb;
            }

        .loading {
            text-align: center;
            color: #666;
            padding: 20px;
        }

        .btn-uniform-size {
            width: 90px;
            height: 30px !important;
            /* Override Bootstrap Padding */
            padding: 0 !important;
            /* Ensure Text Centering */
            line-height: 30px !important; /* Vertical centering */
            text-align: center !important; /* Horizontal centering */
        }

        #rulesTableBody tr {
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }

        #rulesTableBody.tr-fade-out {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>IP Address Management</h1>
            <p>Control access to your application by allowing or blocking IP addresses</p>
        </div>

        <div class="content">
            @if (TempData["SuccessMessage"] != null)
            {
                <div class="message success">@TempData["SuccessMessage"]</div>
            }
            @if (TempData["ErrorMessage"] != null)
            {
                <div class="message error">@TempData["ErrorMessage"]</div>
            }

            <div class="map-section">
                <div class="map-header">
                    <h2>Geographic Distribution</h2>
                </div>
                <div id="map"></div>
                <div class="map-stats">
                    <div class="stat-item">
                        <div class="stat-label">Total IPs</div>
                        <div class="stat-value" id="totalIps">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Countries</div>
                        <div class="stat-value" id="totalCountries">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Allowed</div>
                        <div class="stat-value" id="allowedCount" style="color: #28a745;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Blocked</div>
                        <div class="stat-value" id="blockedCount" style="color: #dc3545;">0</div>
                    </div>
                </div>
            </div>

            <div class="form-section">
                <h2 style="margin-bottom: 20px; color: #333;">Add IP Address Rule</h2>
                <form method="post" asp-page-handler="AddRule">
                    @Html.AntiForgeryToken()
                    <div class="form-group">
                        <label for="ipAddress">IP Address</label>
                        <input type="text" id="ipAddress" name="ipAddress" placeholder="e.g., 192.168.1.1" required>
                    </div>

                    <div class="form-group">
                        <label>Action</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="allow" name="action" value="allow" checked>
                                <label for="allow" style="margin: 0;">Allow</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="block" name="action" value="block">
                                <label for="block" style="margin: 0;">Block</label>
                            </div>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary">Add Rule</button>
                </form>
            </div>

            <hr style="margin: 30px 0;">

            <!-- Filter Buttons -->
            <div class="filter-buttons" style="margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="filterRules('all')">All</button>
                <button class="btn btn-secondary" onclick="filterRules('manual')">Manual</button>
                <button class="btn btn-secondary" onclick="filterRules('automatic')">Automatic</button>
                <button class="btn btn-secondary" onclick="filterRules('malicious')">Malicious</button>
                <button class="btn btn-danger" id="clearAllButton" style="margin-left: 239px" onclick="showClearModal()">Remove All Filtered IPs</button>
            </div>

            <!-- Scrollable Table Wrapper -->
            <div id="rulesContainer" style="max-height: 400px; overflow-y: auto; border: 1px solid #ccc; border-radius: 5px; padding: 10px;">
                <table class="table">
                    <thead>
                        <tr>
                            <th>IP Address</th>
                            <th>Action</th>
                            <th>Added Date</th>
                            <th>Added VIA</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="rulesTableBody">
                        @* Initial load of first page *@
                        @foreach (var rule in Model.IpRules)
                        {
                            <tr data-type="@rule.addType.ToLower()">
                                <td>@rule.IpAddress</td>
                                <td><span class="badge badge-@rule.Action.ToLower()">@rule.Action.ToUpper()</span></td>
                                <td>@rule.DateAdded.ToShortDateString()</td>
                                <td>@rule.addType</td>
                                <td>
                                    <button class="btn btn-success btn-sm action-btn btn-uniform-size" data-action="allow" data-ip="@rule.IpAddress">Allow</button>
                                    <button class="btn btn-warning btn-sm action-btn btn-uniform-size" data-action="block" data-ip="@rule.IpAddress">Block</button>
                                    <button class="btn btn-danger btn-sm action-btn btn-uniform-size" data-action="delete" data-ip="@rule.IpAddress">Remove</button>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>

            @* Pagination Buttons *@
            <nav aria-label="IP rules pagination">
                <ul class="pagination justify-content-center mt-2" id="paginationContainer">
                    @* Initial pagination buttons rendered server-side *@
                </ul>
            </nav>

            <!-- Modal -->
            <div id="clearModal" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); align-items:center; justify-content:center;">
                <div style="background:white; padding:20px; border-radius:8px; max-width:400px; width:90%;">
                    <h4>Confirm Clear All</h4>
                    <p>Are you sure you want to remove all IPs from the selected list?</p>
                    <p>This Will Remove All IPs With the Selected Tag</p>
                    <form method="post" asp-page-handler="ClearAll">
                        @Html.AntiForgeryToken()
                        <input type="hidden" id="filterType" name="filterType" value="">
                        <div style="text-align:right; margin-top:10px;">
                            <button type="button" class="btn btn-secondary" onclick="hideClearModal()">Cancel</button>
                            <button type="submit" class="btn btn-danger" style="height: 48px;">Confirm</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Configuration
        var TIMEOUT_MS = @Json.Serialize(ViewData["MapDynamicTimeout"]);
        var USE_DYNAMIC_TIMEOUT = @Json.Serialize(ViewData["EnableMapDynamicTimeout"]);
        var MAX_CONCURRENT_REQUESTS = @Json.Serialize(ViewData["IPMarkTreadLimit"]);
        var ENABLE_MALICIOUS_MAP_MARKERS = @Json.Serialize(ViewData["EnableMaliciousMapMarkers"]);
        var BATCH_SIZE = @Json.Serialize(ViewData["IPIndexingBatchSize"]);

        console.log(`Map Dynamic Timeout Enabled: ${USE_DYNAMIC_TIMEOUT}`);
        console.log(`Max Concurrent Requests: ${MAX_CONCURRENT_REQUESTS}`);
        console.log(`Enable Malicious Map Markers: ${ENABLE_MALICIOUS_MAP_MARKERS}`);
        console.log(`Timeout MS: ${TIMEOUT_MS}`);
        console.log(`IP Indexing BATCH Size: ${BATCH_SIZE}`);

        let currentFilter = 'all';

        function filterRules(type) {
            currentFilter = type;
            const rows = document.querySelectorAll('#rulesTableBody tr');
            const clearAllButton = document.getElementById('clearAllButton');
            const buttons = document.querySelectorAll('.filter-buttons .btn');

            // Update button highlight
            buttons.forEach(btn => {
                if (btn.textContent.trim().toLowerCase() === type.toLowerCase()) {
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-primary');
                } else {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }
            });

            // Filter rows
            if (type === 'all') {
                rows.forEach(row => row.style.display = '');
                clearAllButton.style.display = 'none';
            } else {
                rows.forEach(row => {
                    if (row.getAttribute('data-type') === type.toLowerCase()) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
                clearAllButton.style.display = 'inline-block';
            }

            let currentPage = @Model.CurrentPage;
            let totalPages = @Model.TotalPages;

            const rulesBody = document.querySelector('#rulesTableBody');
            const paginationContainer = document.querySelector('#paginationContainer');

            function renderPagination() {
                let html = '';

                // Previous
                html += `<li class="page-item ${currentPage == 1 ? 'disabled' : ''}">
                            <a href="#" class="page-link" data-page="${currentPage - 1}">Previous</a>
                         </li>`;

                // First page + ellipsis
                if (currentPage > 4) {
                    html += `<li class="page-item"><a href="#" class="page-link" data-page="1">1</a></li>`;
                    html += `<li class="page-item disabled"><span class="page-link">…</span></li>`;
                }

                // Pages around current
                const startPage = Math.max(1, currentPage - 3);
                const endPage = Math.min(totalPages, currentPage + 3);
                for (let i = startPage; i <= endPage; i++) {
                    html += `<li class="page-item ${i == currentPage ? 'active' : ''}">
                                <a href="#" class="page-link" data-page="${i}">${i}</a>
                             </li>`;
                }

                // Last page + ellipsis
                if (currentPage + 3 < totalPages) {
                    html += `<li class="page-item disabled"><span class="page-link">…</span></li>`;
                    html += `<li class="page-item"><a href="#" class="page-link" data-page="${totalPages}">${totalPages}</a></li>`;
                }

                // Next
                html += `<li class="page-item ${currentPage == totalPages ? 'disabled' : ''}">
                            <a href="#" class="page-link" data-page="${currentPage + 1}">Next</a>
                         </li>`;

                paginationContainer.innerHTML = html;
                attachPaginationEvents();
            }

            function attachPaginationEvents() {
                document.querySelectorAll('#paginationContainer .page-link').forEach(link => {
                    link.addEventListener('click', e => {
                        e.preventDefault();
                        const page = parseInt(e.target.dataset.page);
                        if (page >= 1 && page <= totalPages) {
                            loadPage(page);
                        }
                    });
                });
            }

            function loadPage(page) {
                const rulesBody = document.querySelector('#rulesTableBody');
                const rulesContainer = document.querySelector('#rulesContainer');

                // Fade out existing rows first
                rulesBody.classList.add('tr-fade-out');

                fetch(`/Index?handler=IpRulesPageJson&page=${page}&filter=${currentFilter}`)
                .then(res => res.json())
                .then(data => {
                    // After fade out, replace content
                    setTimeout(() => {
                        let html = '';
                        data.rules.forEach(rule => {
                            html += `<tr data-type="${rule.addType.toLowerCase()}">
                                        <td>${rule.ipAddress}</td>
                                        <td><span class="badge badge-${rule.action.toLowerCase()}">${rule.action.toUpperCase()}</span></td>
                                        <td>${new Date(rule.dateAdded).toLocaleDateString()}</td>
                                        <td>${rule.addType}</td>
                                        <td>
                                            <button class="btn btn-success btn-sm action-btn btn-uniform-size" data-action="allow" data-ip="${rule.ipAddress}">Allow</button>
                                            <button class="btn btn-warning btn-sm action-btn btn-uniform-size" data-action="block" data-ip="${rule.ipAddress}">Block</button>
                                            <button class="btn btn-danger btn-sm action-btn btn-uniform-size" data-action="delete" data-ip="${rule.ipAddress}">Remove</button>
                                        </td>
                                     </tr>`;
                        });

                        rulesBody.innerHTML = html;

                        // Remove fade class to trigger fade-in
                        rulesBody.classList.remove('tr-fade-out');

                        scrollToTopAccelerating(document.getElementById('rulesContainer'), 400);


                        // Update pagination
                        currentPage = page;
                        totalPages = data.totalPages;
                        renderPagination();
                    }, 200); // matches half of the CSS transition for smoothness
                });
            }


            // **Initial load of page content**
            loadPage(currentPage);
        }

        document.addEventListener('DOMContentLoaded', () => {
            let currentPage = @Model.CurrentPage;
            let totalPages = @Model.TotalPages;

            const rulesBody = document.querySelector('#rulesTableBody');
            const paginationContainer = document.querySelector('#paginationContainer');

            function renderPagination() {
                let html = '';

                // Previous
                html += `<li class="page-item ${currentPage == 1 ? 'disabled' : ''}">
                            <a href="#" class="page-link" data-page="${currentPage - 1}">Previous</a>
                         </li>`;

                // First page + ellipsis
                if (currentPage > 4) {
                    html += `<li class="page-item"><a href="#" class="page-link" data-page="1">1</a></li>`;
                    html += `<li class="page-item disabled"><span class="page-link">…</span></li>`;
                }

                // Pages around current
                const startPage = Math.max(1, currentPage - 3);
                const endPage = Math.min(totalPages, currentPage + 3);
                for (let i = startPage; i <= endPage; i++) {
                    html += `<li class="page-item ${i == currentPage ? 'active' : ''}">
                                <a href="#" class="page-link" data-page="${i}">${i}</a>
                             </li>`;
                }

                // Last page + ellipsis
                if (currentPage + 3 < totalPages) {
                    html += `<li class="page-item disabled"><span class="page-link">…</span></li>`;
                    html += `<li class="page-item"><a href="#" class="page-link" data-page="${totalPages}">${totalPages}</a></li>`;
                }

                // Next
                html += `<li class="page-item ${currentPage == totalPages ? 'disabled' : ''}">
                            <a href="#" class="page-link" data-page="${currentPage + 1}">Next</a>
                         </li>`;

                paginationContainer.innerHTML = html;
                attachPaginationEvents();
            }

            function attachPaginationEvents() {
                document.querySelectorAll('#paginationContainer .page-link').forEach(link => {
                    link.addEventListener('click', e => {
                        e.preventDefault();
                        const page = parseInt(e.target.dataset.page);
                        if (page >= 1 && page <= totalPages) {
                            loadPage(page);
                        }
                    });
                });
            }

            function loadPage(page) {
                const rulesBody = document.querySelector('#rulesTableBody');
                const rulesContainer = document.querySelector('#rulesContainer');

                // Fade out existing rows first
                rulesBody.classList.add('tr-fade-out');

                fetch(`/Index?handler=IpRulesPageJson&page=${page}&filter=${currentFilter}`)
                .then(res => res.json())
                .then(data => {
                    // After fade out, replace content
                    setTimeout(() => {
                        let html = '';
                        data.rules.forEach(rule => {
                            html += `<tr data-type="${rule.addType.toLowerCase()}">
                                        <td>${rule.ipAddress}</td>
                                        <td><span class="badge badge-${rule.action.toLowerCase()}">${rule.action.toUpperCase()}</span></td>
                                        <td>${new Date(rule.dateAdded).toLocaleDateString()}</td>
                                        <td>${rule.addType}</td>
                                        <td>
                                            <button class="btn btn-success btn-sm action-btn btn-uniform-size" data-action="allow" data-ip="${rule.ipAddress}">Allow</button>
                                            <button class="btn btn-warning btn-sm action-btn btn-uniform-size" data-action="block" data-ip="${rule.ipAddress}">Block</button>
                                            <button class="btn btn-danger btn-sm action-btn btn-uniform-size" data-action="delete" data-ip="${rule.ipAddress}">Remove</button>
                                        </td>
                                     </tr>`;
                        });

                        rulesBody.innerHTML = html;

                        // Remove fade class to trigger fade-in
                        rulesBody.classList.remove('tr-fade-out');

                        scrollToTopAccelerating(document.getElementById('rulesContainer'), 400);


                        // Update pagination
                        currentPage = page;
                        totalPages = data.totalPages;
                        renderPagination();
                    }, 200); // matches half of the CSS transition for smoothness
                });
            }


            // **Initial load of page content**
            loadPage(currentPage);
        });

        function scrollToTopAccelerating(container, duration = 600) {
            const start = container.scrollTop;
            const startTime = performance.now();

            function animate(time) {
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1); // 0 → 1

                // Accelerating effect: quadratic easing in
                const easedProgress = progress * progress;

                container.scrollTop = start * (1 - easedProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            requestAnimationFrame(animate);
        }


        function showClearModal() {
            document.getElementById('filterType').value = currentFilter;
            document.getElementById('clearModal').style.display = 'flex';
        }

        function hideClearModal() {
            document.getElementById('clearModal').style.display = 'none';
        }

        // Default view
        document.addEventListener('DOMContentLoaded', () => filterRules('all'));

        // Initialize the map
        const map = L.map('map').setView([20, 0], 2);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);

        // Get IP addresses from the table
        const ipRules = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.IpRulesFull));
        const ipAddresses = ipRules
            .filter(r => r.ipAddress) // skip invalid entries
            .map(r => ({
                ip: r.ipAddress,
                action: r.action ? r.action.toLowerCase() : 'unknown'  // default if missing
            }));

        const rows = document.querySelectorAll('#rulesTableBody tr:not(.empty-state)');

        let processed = 0;

        (async () => {
            let processed = 0;

            let start = 0;

            const processBatch = () => {
                const end = Math.min(start + BATCH_SIZE, rows.length);

                for (let i = start; i < end; i++) {
                    const row = rows[i];

                    // skip empty-state row
                    if (row.classList.contains('empty-state')) continue;

                    // get addType from data attribute
                    const addType = row.dataset.type;
                    if (!ENABLE_MALICIOUS_MAP_MARKERS && addType === 'malicious') continue;

                    const cells = row.children;
                    const ip = cells[0].textContent.trim();
                    const action = cells[1].textContent.trim().toLowerCase();

                    ipAddresses.push({ ip, action });
                    processed++;
                }

                start = end;

                if (start < rows.length) {
                    requestIdleCallback(processBatch);
                } else {
                    console.log('Finished processing', ipAddresses.length, 'rows');
                    // here you can continue with ipAddresses
                }
            };

            processBatch();
        })();

        // Function to get geolocation for an IP
        async function getIpLocation(ip) {
            try {
                // First, try local GeoIP lookup via Razor Page handler
                const protocol = window.location.protocol;
                const host = window.location.host;
                const localUrl = `${protocol}//${host}?handler=GeoIp&ipAddress=${encodeURIComponent(ip)}`;

                console.log(`[GeoIP] Attempting local lookup for ${ip}...`);
                const localResponse = await fetch(localUrl);

                if (localResponse.ok) {
                    const data = await localResponse.json();
                    if (data.success && data.latitude && data.longitude) {
                        console.log(`✓ [GeoIP Local] ${ip} -> ${data.city}, ${data.country} (${data.countryCode})`);
                        return {
                            ip: ip,
                            country: data.country,
                            countryCode: data.countryCode,
                            city: data.city || 'Unknown',
                            lat: data.latitude,
                            lon: data.longitude,
                            source: 'local'
                        };
                    } else {
                        console.log(`⚠ [GeoIP Local] No data found for ${ip}, trying fallback...`);
                    }
                } else {
                    console.log(`⚠ [GeoIP Local] Request failed (${localResponse.status}), trying fallback...`);
                }

                // Fallback to ip-api.com (free, no key required, 45 requests/min)
                console.log(`[GeoIP Fallback] Using external API (ip-api.com) for ${ip}...`);
                const externalProtocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
                const fallbackResponse = await fetch(`${externalProtocol}//ip-api.com/json/${ip}?fields=status,country,countryCode,city,lat,lon`);
                const fallbackData = await fallbackResponse.json();

                if (fallbackData.status === 'success') {
                    console.log(`✓ [GeoIP Fallback] ${ip} -> ${fallbackData.city}, ${fallbackData.country} (${fallbackData.countryCode})`);
                    return {
                        ip: ip,
                        country: fallbackData.country,
                        countryCode: fallbackData.countryCode,
                        city: fallbackData.city || 'Unknown',
                        lat: fallbackData.lat,
                        lon: fallbackData.lon,
                        source: 'external'
                    };
                } else {
                    console.log(`✗ [GeoIP Fallback] Failed for ${ip}: ${fallbackData.message || 'Unknown error'}`);
                }

                return null;
            } catch (error) {
                console.error(`✗ [GeoIP Error] Failed to fetch location for ${ip}:`, error);
                return null;
            }
        }

        // Object to track markers by location
        const markersByLocation = {};

        // Function to get a location key for grouping
        function getLocationKey(lat, lon) {
            // Round to 2 decimal places to group nearby IPs
            return `${lat.toFixed(2)},${lon.toFixed(2)}`;
        }

        // Function to add markers to the map
        function addMarker(location, action) {
            const locationKey = getLocationKey(location.lat, location.lon);

            // Initialize marker data if it doesn't exist
            if (!markersByLocation[locationKey]) {
                markersByLocation[locationKey] = {
                    lat: location.lat,
                    lon: location.lon,
                    city: location.city,
                    country: location.country,
                    ips: []
                };
            }

            // Add this IP to the location
            markersByLocation[locationKey].ips.push({
                ip: location.ip,
                action: action
            });

            // Remove existing marker if it exists
            if (markersByLocation[locationKey].marker) {
                map.removeLayer(markersByLocation[locationKey].marker);
            }

            const ips = markersByLocation[locationKey].ips;
            const allowCount = ips.filter(ip => ip.action === 'allow').length;
            const blockCount = ips.filter(ip => ip.action === 'block').length;

            // Determine color based on majority action
            let color;
            if (allowCount > blockCount) {
                color = '#28a745'; // Green for mostly allowed
            } else if (blockCount > allowCount) {
                color = '#dc3545'; // Red for mostly blocked
            } else {
                color = '#ffc107'; // Yellow for mixed
            }

            // Create marker with size based on number of IPs
            const size = Math.min(12 + (ips.length * 2), 24); // Grows with more IPs, max 24px
            const icon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="background-color: ${color}; width: ${size}px; height: ${size}px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;">${ips.length > 1 ? ips.length : ''}</div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });

            const marker = L.marker([location.lat, location.lon], { icon }).addTo(map);

            // Build popup content
            let popupContent = `<div style="max-width: 250px;">`;
            popupContent += `<strong>${location.city}, ${location.country}</strong><br>`;
            popupContent += `<div style="margin-top: 8px;">`;

            if (ips.length === 1) {
                // Single IP - simple display
                const ipData = ips[0];
                const ipColor = ipData.action === 'allow' ? '#28a745' : '#dc3545';
                popupContent += `<strong>${ipData.ip}</strong><br>`;
                popupContent += `<span style="color: ${ipColor}; font-weight: 600;">${ipData.action.toUpperCase()}</span>`;
            } else {
                // Multiple IPs - show list
                popupContent += `<strong>${ips.length} IP Addresses:</strong><br>`;
                popupContent += `<div style="max-height: 150px; overflow-y: auto; margin-top: 5px;">`;
                ips.forEach(ipData => {
                    const ipColor = ipData.action === 'allow' ? '#28a745' : '#dc3545';
                    popupContent += `<div style="padding: 3px 0; border-bottom: 1px solid #eee;">`;
                    popupContent += `<code style="font-size: 11px;">${ipData.ip}</code> `;
                    popupContent += `<span style="color: ${ipColor}; font-weight: 600; font-size: 10px;">${ipData.action.toUpperCase()}</span>`;
                    popupContent += `</div>`;
                });
                popupContent += `</div>`;
                popupContent += `<div style="margin-top: 8px; font-size: 11px; color: #666;">`;
                popupContent += `<span style="color: #28a745;">✓ ${allowCount} allowed</span> | `;
                popupContent += `<span style="color: #dc3545;">✗ ${blockCount} blocked</span>`;
                popupContent += `</div>`;
            }

            popupContent += `</div></div>`;
            marker.bindPopup(popupContent);

            // Store marker reference
            markersByLocation[locationKey].marker = marker;
        }

        // Function to update stats
        function updateStats(locations, allowedCount, blockedCount) {
            const countries = new Set(locations.map(loc => loc.country));
            document.getElementById('totalIps').textContent = ipAddresses.length;
            document.getElementById('totalCountries').textContent = countries.size;
            document.getElementById('allowedCount').textContent = allowedCount;
            document.getElementById('blockedCount').textContent = blockedCount;

            // Fit map to markers if we have locations
            if (locations.length > 0) {
                const bounds = L.latLngBounds(locations.map(loc => [loc.lat, loc.lon]));
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // Function to process IPs in parallel with concurrency limit
        async function processIpBatch(ipAddresses, maxConcurrent) {
            const results = [];
            const executing = [];

            for (const ipData of ipAddresses) {
                const promise = getIpLocation(ipData.ip).then(location => {
                    if (location) {
                        return { location, action: ipData.action };
                    }
                    return null;
                });

                results.push(promise);

                if (maxConcurrent <= ipAddresses.length) {
                    const e = promise.then(() => executing.splice(executing.indexOf(e), 1));
                    executing.push(e);

                    if (executing.length >= maxConcurrent) {
                        await Promise.race(executing);
                    }
                }
            }

            return Promise.all(results);
        }

        // Load and display IP locations with timeout
        async function loadIpLocations() {
            if (ipAddresses.length === 0) {
                return;
            }

            const locations = [];
            let allowedCount = 0;
            let blockedCount = 0;
            const startTime = Date.now();

            // Calculate timeout dynamically or use fixed value
            let timeoutMs;
            if (USE_DYNAMIC_TIMEOUT) {
                // Dynamic calculation: with parallel requests, we can be more aggressive
                const estimatedTimePerBatch = 1500; // milliseconds per batch
                const batches = Math.ceil(ipAddresses.length / MAX_CONCURRENT_REQUESTS);
                timeoutMs = Math.max(3000, Math.min(30000, batches * estimatedTimePerBatch));
                console.log(`Using dynamic timeout: ${timeoutMs}ms for ${ipAddresses.length} IPs (${batches} batches)`);
            } else {
                timeoutMs = TIMEOUT_MS;
            }

            // Create a timeout promise
            const timeoutPromise = new Promise(resolve => setTimeout(() => resolve('timeout'), timeoutMs));

            // Process IPs in parallel
            const resultsPromise = processIpBatch(ipAddresses, MAX_CONCURRENT_REQUESTS);

            // Race between getting results and timeout
            const outcome = await Promise.race([resultsPromise, timeoutPromise]);

            if (outcome === 'timeout') {
                console.log(`Timeout reached after ${timeoutMs}ms. Displaying partial results.`);
                // Give a small grace period to finish any in-flight requests
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Get whatever results we have
            const results = await Promise.allSettled([resultsPromise].flat());
            const completedResults = outcome === 'timeout' ? [] : await resultsPromise;

            // Process completed results
            for (const result of completedResults) {
                if (result && result.location) {
                    locations.push({ ...result.location, action: result.action });
                    addMarker(result.location, result.action);

                    if (result.action === 'allow') allowedCount++;
                    else if (result.action === 'block') blockedCount++;
                }
            }

            // Update stats with whatever we have
            updateStats(locations, allowedCount, blockedCount);

            const elapsed = Date.now() - startTime;
            console.log(`Loaded ${locations.length} of ${ipAddresses.length} locations in ${elapsed}ms`);
        }

        // Initialize the map with data
        loadIpLocations();
    </script>
</body>
</html>